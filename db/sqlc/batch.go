// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: batch.go

package sqlc

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const batchUpdateSendingEmailsStatus = `-- name: BatchUpdateSendingEmailsStatus :batchmany
UPDATE sending_emails
SET status     = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, subscriber_id, newsletter_id, status, created_at, updated_at
`

type BatchUpdateSendingEmailsStatusBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchUpdateSendingEmailsStatusParams struct {
	ID     uuid.UUID
	Status Status
}

func (q *Queries) BatchUpdateSendingEmailsStatus(ctx context.Context, arg []BatchUpdateSendingEmailsStatusParams) *BatchUpdateSendingEmailsStatusBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Status,
		}
		batch.Queue(batchUpdateSendingEmailsStatus, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchUpdateSendingEmailsStatusBatchResults{br, len(arg), false}
}

func (b *BatchUpdateSendingEmailsStatusBatchResults) Query(f func(int, []SendingEmail, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []SendingEmail
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i SendingEmail
				if err := rows.Scan(
					&i.ID,
					&i.SubscriberID,
					&i.NewsletterID,
					&i.Status,
					&i.CreatedAt,
					&i.UpdatedAt,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *BatchUpdateSendingEmailsStatusBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createSendingEmails = `-- name: CreateSendingEmails :batchmany
INSERT INTO sending_emails (subscriber_id, newsletter_id, status)
    VALUES ($1, $2, 'pending')
    RETURNING id, subscriber_id, newsletter_id, status, created_at, updated_at, (SELECT email FROM subscribers WHERE id = $1) AS email, (SELECT header FROM newsletters WHERE id = $2) AS header, (SELECT body FROM newsletters WHERE id = $2) AS body
`

type CreateSendingEmailsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateSendingEmailsParams struct {
	SubscriberID uuid.UUID
	NewsletterID uuid.UUID
}

type CreateSendingEmailsRow struct {
	ID           uuid.UUID
	SubscriberID uuid.UUID
	NewsletterID uuid.UUID
	Status       Status
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	Email        string
	Header       string
	Body         string
}

func (q *Queries) CreateSendingEmails(ctx context.Context, arg []CreateSendingEmailsParams) *CreateSendingEmailsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.SubscriberID,
			a.NewsletterID,
		}
		batch.Queue(createSendingEmails, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateSendingEmailsBatchResults{br, len(arg), false}
}

func (b *CreateSendingEmailsBatchResults) Query(f func(int, []CreateSendingEmailsRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []CreateSendingEmailsRow
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i CreateSendingEmailsRow
				if err := rows.Scan(
					&i.ID,
					&i.SubscriberID,
					&i.NewsletterID,
					&i.Status,
					&i.CreatedAt,
					&i.UpdatedAt,
					&i.Email,
					&i.Header,
					&i.Body,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *CreateSendingEmailsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
